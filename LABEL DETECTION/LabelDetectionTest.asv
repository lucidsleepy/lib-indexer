img = imread('input2.jpg');
img_double = im2double(img);
img_grey = rgb2gray(img_double);

test_img_threshold = (img_grey > 0.85) & (img_grey < 0.95);

%{
imshow(img_threshold);
figure(2);
se = strel('rectangle', [5,5]);
imshow(imdilate(img_threshold, se));
%}

%% CORNER DETECTION
img_grey_gaus = imgaussfilt(img_grey, 4);
corners = corner(img_grey_gaus, 5000, 'FilterCoefficients', fspecial('gaussian',[3 1], 2));
img_corner_highlight = img_grey;

imshow(img_corner_highlight);
hold on;
for c = 1:size(corners, 1)
    th = 0:pi/50:2*pi;
    r = 5;
    x = r * cos(th) + corners(c, 1);
    y = r * sin(th) + corners(c, 2);
    plot(x, y, 'r');
end
hold off;

%% INTEGRAL IMAGING
img_integral = generate_integral_image(img_grey);

%% FIND LABELS
brights_darks_ratio_range = [10, 20];   % ratio between II brightness sum/II darkness sum [min acceptable, max acceptable]
x_diff_range = [50, 100];               % absolute distance that two corners need to be apart in x direction [min, max]
y_diff_range = [75, 125];               % absolute distance that two corners need to be apart in y direction [min, max]
labels = [];

for c = 1:size(corners, 1)              % for every corner, find neighbors within x_diff_range and y_diff_range and check bright/dark ratio
    % quadtree to find neaarest neighbor with minimum distance of
    % [x_diff_range(1), y_diff_range(1)] and maximum distance of [x_diff_range(2), y_diff_range(2)]
    % if no other corner is in range, ignore the current corner and move on
    % if another corner is found in range, do integral imaging and
    % calculate the brightness/darkness ratio

    neighbors = find_neighbors(corners, corners(c), x_diff_range, y_diff_range);
    for n = 1:size(neighbors, 1)
        if check_if_label(img_integral, corners(c), neighbors(1), brights_darks_ratio_range)
            labels = [labels; corners(c), neighbors(1)];
        end
    end
    
end

% labels contains final result

%% FUNCTIONS
function result = find_neighbors(coords, target_coords, x_diff_range, y_diff_range)
    % find nearest neighbors in range (e.g. with quadtree)
end

%{
    Returns true if the two target vectors could describe a label (based on
    a heuristic), or false if it is no label that can be detected.

    Sources:
        http://delivery.acm.org/10.1145/810000/808600/p207-crow.pdf
        accessed on 2019/11/12

        https://en.wikipedia.org/wiki/Summed-area_table#/media/File:Summed_area_table.png
        used only for variable naming
        accessed on 2019/11/12

    Author:
        Laurenz Edmund Fiala (11807869)
%}
function result = check_if_label(integral_image, target_coords, target_coords_2, brights_darks_ratio_range)
    
    A = integral_image(target_coords);
    B = integral_image([target_coords(1), target_coords_2(2)]);
    C = integral_image([target_coords(2), target_coords_2(1)]);
    D = integral_image(target_coords_2);
    
    target_diff   = abs(diff([target_coords(1), target_coords_2(1), target_coords(2), target_coords_2(2)]));
    ii_max_value  = target_diff(1) * target_diff(2);
    ii_brightness = D + A - B - C;
    ii_darkness   = ii_max_value - ii_brightness;
    
    ii_bright_dark_ratio = ii_brightness / ii_darkness;
    
    result = ii_bright_dark_ratio >= brights_darks_ratio_range(1) & ...
             ii_bright_dark_ratio <= brights_darks_ratio_range(2);

end

%{
    Returns an integral image (also called summed area table) from the
    given grayscale image (2-dimensional, [0, 1]-image).

    Sources:
        http://delivery.acm.org/10.1145/810000/808600/p207-crow.pdf
        accessed on 2019/11/12

    Author:
        Laurenz Edmund Fiala (11807869)
%}
function result = generate_integral_image(greyscale_image)
    
    result = greyscale_image;
    for x = 1:size(greyscale_image, 1)
       for y = 1:size(greyscale_image, 2)
           
           result(x, y) =   result( max(x-1, 1),    max(y-1, 1)) + ...
                            result(           x,    max(y-1, 1)) + ...
                            result( max(x-1, 1),              y) + ...
                            result(           x,              y);
           
       end
    end

end

%{
    Detect corners in the given binary image (already edge-filtered) and
    return the detected points as line vectors.
%}
function result = detect_corners(binary_edge_image)
    
    im = edge(rgb2gray(im2double(imread('input2.jpg'))), 'sobel');

    dx = fspecial('gaussian', [1 9], 5);
    dy = fspecial('gaussian', [9 1], 5);
    
    % Step 1: Compute derivatives of image
    Ix = conv2(im, dx, 'same');
    Iy = conv2(im, dy, 'same');

    % Step 2: Smooth space image derivatives (gaussian filtering)
    Ix2 = imgaussfilt(Ix .^ 2, [1 9]);
    Iy2 = imgaussfilt(Iy .^ 2, [9 1]);
    Ixy = imgaussfilt(Ix .* Iy, 9);

    % Step 3: Harris corner measure
    harris = (Ix2 .* Iy2 - Ixy .^ 2) ./ (Ix2 + Iy2);

    % Step 4: Find local maxima (non maximum suppression)
    mx = ordfilt2(harris, size(im, 1) .^ 2, ones(size(im, 1)));
    
    plot(mx);

    % Step 5: Thresholding
    harris = (harris == mx) & (harris > threshold);
    
    
    im = rgb2gray(im2double(imread('input2.jpg')));
figure ;imshow(im);
im1=im2double(im);
figure ;imshow(im1);
dx = [-1 0 1; -1 0 1; -1 0 1]; % image derivatives
dy = dx';
Ix = imfilter(im1, dx);    % Step 1: Compute the image derivatives Ix and Iy
Iy = imfilter(im1, dy);
g = fspecial('gaussian',9,2); % Step 2: Generate Gaussian filter 'g' of size 9x9 and standard deviation Sigma=2.
Ix2 = imfilter(Ix.^2, g); % Step 3: Smooth the squared image derivatives to obtain Ix2, Iy2 and IxIy
figure;imshow(Ix2);
Iy2 = imfilter(Iy.^2, g);
figure;imshow(Iy2);
IxIy = imfilter(Ix.*Iy, g);
figure;imshow(IxIy);

end

